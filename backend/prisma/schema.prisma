generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                     String        @id
  name                   String        @default("Anonymous")
  bio                    String?
  image                  String?
  hasCompletedOnboarding Boolean       @default(false)
  pushToken              String?
  pushNotificationsEnabled Boolean     @default(true)
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @default(now()) @updatedAt
  messages               Message[]
  createdChats           Chat[]        @relation("ChatCreator")
  chatMemberships        ChatMember[]
  readReceipts           ReadReceipt[]
  reactions              Reaction[]
  bookmarks              Bookmark[]
  mentions               Mention[]              @relation("UserMentions")
  mentionedIn            Mention[]              @relation("MentionedUser")

  @@map("user")
}

model Chat {
  id                    String           @id @default(cuid())
  name                  String           @default("New Chat")
  bio                   String?
  image                 String?
  aiPersonality         String?
  aiTone                String?
  aiName                String?          @default("AI Assistant")
  aiEngagementMode      String           @default("on-call")  // "on-call", "percentage", "off"
  aiEngagementPercent   Int?             // 0-100, only used when mode is "percentage"
  lastAvatarGenDate     DateTime?
  avatarPromptUsed      String?
  inviteToken           String?          @unique
  inviteTokenExpiresAt  DateTime?
  creatorId             String
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @default(now()) @updatedAt
  creator               User             @relation("ChatCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  members               ChatMember[]
  messages              Message[]
  customCommands        CustomSlashCommand[]
  readReceipts          ReadReceipt[]
  threads               Thread[]         @relation("ChatThreads")
  events                Event[]          @relation("ChatEvents")
  aiFriends             AIFriend[]       @relation("ChatAIFriends")

  @@map("chat")
}

model ChatMember {
  id        String    @id @default(cuid())
  chatId    String
  userId    String
  joinedAt  DateTime  @default(now())
  isPinned  Boolean   @default(false)
  pinnedAt  DateTime?
  chat      Chat      @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@map("chat_member")
}

model Message {
  id               String      @id @default(cuid())
  content          String      @default("")
  messageType      String      @default("text")
  imageUrl         String?
  imageDescription String?
  userId           String
  chatId           String
  replyToId        String?
  aiFriendId       String?     // Reference to which AI friend sent this message (if userId is "ai-assistant")
  // Link preview fields
  linkPreviewUrl         String?
  linkPreviewTitle       String?
  linkPreviewDescription String?
  linkPreviewImage       String?
  linkPreviewSiteName    String?
  linkPreviewFavicon     String?
  // Edit and unsend fields
  editedAt         DateTime?
  isUnsent         Boolean     @default(false)
  editHistory      String?     // JSON string storing edit history
  // Voice message fields
  voiceUrl         String?
  voiceDuration    Int?        // Duration in seconds
  // Event reference for event notification messages
  eventId          String?
  createdAt        DateTime    @default(now())
  user             User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat             Chat        @relation(fields: [chatId], references: [id], onDelete: Cascade)
  replyTo          Message?    @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies          Message[]   @relation("MessageReplies")
  reactions        Reaction[]
  readReceipts     ReadReceipt[]
  bookmarks        Bookmark[]
  tags             MessageTag[] @relation("MessageTags")
  mentions         Mention[]    @relation("MessageMentions")
  aiFriend         AIFriend?   @relation("AIFriendMessages", fields: [aiFriendId], references: [id], onDelete: SetNull)

  @@map("message")
}

model Reaction {
  id        String   @id @default(cuid())
  emoji     String
  userId    String
  messageId String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId, emoji])
  @@map("reaction")
}

model CustomSlashCommand {
  id          String   @id @default(cuid())
  command     String
  prompt      String
  chatId      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  chat        Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)

  @@unique([chatId, command])
  @@map("custom_slash_command")
}

model ReadReceipt {
  id        String   @id @default(cuid())
  userId    String
  chatId    String
  messageId String
  readAt    DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId])
  @@index([userId, chatId])
  @@map("read_receipt")
}

model Bookmark {
  id          String   @id @default(cuid())
  userId      String
  chatId      String
  messageId   String
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId])
  @@index([userId, chatId])
  @@map("bookmark")
}

model Mention {
  id                String   @id @default(cuid())
  messageId         String
  mentionedUserId   String
  mentionedByUserId String
  createdAt         DateTime @default(now())
  message           Message  @relation("MessageMentions", fields: [messageId], references: [id], onDelete: Cascade)
  mentionedUser     User     @relation("MentionedUser", fields: [mentionedUserId], references: [id], onDelete: Cascade)
  mentionedBy       User     @relation("UserMentions", fields: [mentionedByUserId], references: [id], onDelete: Cascade)

  @@unique([messageId, mentionedUserId])
  @@index([mentionedUserId])
  @@index([messageId])
  @@map("mention")
}

// ============================================
// AI FRIENDS - MULTIPLE AI ASSISTANTS
// ============================================

// AI Friend: Individual AI assistants per chat
model AIFriend {
  id                  String    @id @default(cuid())
  chatId              String
  name                String    @default("AI Friend")
  personality         String?   // Custom personality instructions
  tone                String?   // Quick tone selection
  engagementMode      String    @default("on-call")  // "on-call", "percentage", "off"
  engagementPercent   Int?      // 0-100, only used when mode is "percentage"
  color               String    @default("#34C759")  // Hex color for UI theming
  sortOrder           Int       @default(0)  // Order in which AI friends are displayed
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @default(now()) @updatedAt
  chat                Chat      @relation("ChatAIFriends", fields: [chatId], references: [id], onDelete: Cascade)
  messages            Message[] @relation("AIFriendMessages")

  @@index([chatId])
  @@index([chatId, sortOrder])
  @@map("ai_friend")
}

// ============================================
// AI SUPER FEATURES - NEW MODELS
// ============================================

// Smart Threads: Thread definitions
model Thread {
  id          String   @id @default(cuid())
  chatId      String
  name        String
  icon        String   @default("ðŸ’¬")
  creatorId   String
  isShared    Boolean  @default(false)
  filterRules String   // JSON: {"topics": ["food"], "keywords": [...], "people": [...]}
  memberIds   String   // JSON array: ["user1", "user2", ...]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  chat        Chat     @relation("ChatThreads", fields: [chatId], references: [id], onDelete: Cascade)
  members     ThreadMember[]

  @@index([chatId])
  @@map("thread")
}

// Smart Threads: Message tagging (AI-generated)
model MessageTag {
  id         String   @id @default(cuid())
  messageId  String
  tagType    String   // "topic", "entity", "person", "intent", "sentiment"
  tagValue   String
  confidence Float    @default(0.9) // 0.0 to 1.0
  createdAt  DateTime @default(now())
  message    Message  @relation("MessageTags", fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([tagType, tagValue])
  @@map("message_tag")
}

// Smart Threads: Thread membership
model ThreadMember {
  id           String   @id @default(cuid())
  threadId     String
  userId       String
  joinedAt     DateTime @default(now())
  lastViewedAt DateTime @default(now()) @updatedAt
  sortOrder    Int      @default(0)
  thread       Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId])
  @@map("thread_member")
}

// Events: Event definitions
model Event {
  id          String   @id @default(cuid())
  chatId      String
  title       String
  description String?
  eventType   String   @default("general") // "dinner", "trip", "meeting", "general"
  status      String   @default("planning") // "planning", "finalized", "cancelled"
  eventDate   DateTime? // The actual date/time when the event will happen
  finalizedAt DateTime?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  chat        Chat     @relation("ChatEvents", fields: [chatId], references: [id], onDelete: Cascade)
  options     EventOption[]
  responses   EventResponse[]

  @@index([chatId])
  @@index([status])
  @@map("event")
}

// Events: Event options (time/location choices)
model EventOption {
  id         String   @id @default(cuid())
  eventId    String
  optionType String   // "time", "location"
  value      String   // "7:00 PM", "Mario's Italian"
  voteCount  Int      @default(0)
  createdAt  DateTime @default(now())
  event      Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  responses  EventResponse[]

  @@index([eventId])
  @@map("event_option")
}

// Events: User responses to events
model EventResponse {
  id           String   @id @default(cuid())
  eventId      String
  userId       String
  optionId     String?  // null for RSVP-only responses
  responseType String   // "yes", "no", "maybe" for RSVP; "vote" for option selection
  createdAt    DateTime @default(now())
  updatedAt    DateTime @default(now()) @updatedAt
  event        Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  option       EventOption? @relation(fields: [optionId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId, optionId])
  @@index([eventId])
  @@index([userId])
  @@map("event_response")
}

// Content Reactor: Media reactions
model MediaReaction {
  id           String   @id @default(cuid())
  messageId    String
  userId       String
  reactionType String   // "caption", "roast", "remix", "meme", "explain", "style_transfer", "remove_bg"
  resultUrl    String?  // URL to generated content
  metadata     String?  // JSON: additional info like captions array, style used, etc.
  createdAt    DateTime @default(now())

  @@index([messageId])
  @@index([userId])
  @@map("media_reaction")
}

// Catch-Up: Conversation summaries (cached)
model ConversationSummary {
  id           String   @id @default(cuid())
  chatId       String
  userId       String
  summaryType  String   // "quick", "standard", "deep_dive"
  content      String   // JSON: structured summary data
  messageRange String   // JSON: {startMessageId, endMessageId, count}
  createdAt    DateTime @default(now())
  expiresAt    DateTime // Summaries expire after 1 hour

  @@index([chatId, userId])
  @@index([expiresAt])
  @@map("conversation_summary")
}
